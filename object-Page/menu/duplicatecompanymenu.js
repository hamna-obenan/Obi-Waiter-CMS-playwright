import { expect } from '@playwright/test';
import locators from '../../Fixtures/locators.json' assert { type: "json" };

/**
 * Page Object Model for Duplicate Company Menu Testing
 * Handles duplicate menu creation with company selection, form filling, and image uploads
 */
export default class DuplicateCompanyMenuPOM {
  constructor(page) {
    this.page = page;
  }

  /**
   * Navigate to Create Menu page with company flow: Select Venue ‚Üí Add Menu ‚Üí Create ‚Üí Company ‚Üí Fill Form
   */
  async navigateToCreateMenu() {
    // Step 1: Select the venue first
    await this.selectVenue();

    // Step 2: Click on Add Menu using locators
    await this.page.locator(locators["click-on-the-add-menu"]).click();
    await this.page.waitForLoadState('networkidle');
    console.log('‚úÖ Clicked on Add Menu');

    // Step 3: Click on Create using locators
    await this.page.locator(locators["create-button"]).click();
    await this.page.waitForLoadState('networkidle');
    console.log('‚úÖ Clicked on Create');

    // Step 4: Click on Company using locators
    await this.page.locator(locators["company-button"]).click();
    await this.page.waitForLoadState('networkidle');
    console.log('‚úÖ Clicked on Company');

    console.log('‚úÖ Navigated to Create Menu page with company flow');
  }

  /**
   * Select the added venue
   */
  async selectVenue() {
    console.log('üè¢ Selecting venue...');
    // Wait for venue list to load
    await this.page.waitForTimeout(2000);

    // Click on the created venue using locators
    await this.page.locator(locators["click-on-the-created-venue"]).click();
    await this.page.waitForLoadState('networkidle');
    console.log('‚úÖ Venue selected');
  }

  /**
   * Fill menu name only
   * @param {string} menuName - Menu name from fixture
   */
  async fillMenuName(menuName) {
    console.log('üìù Filling menu name...');
    await this.page.locator(locators["click-on-the-menu-name"]).fill(menuName);
    await expect(this.page.locator(locators["click-on-the-menu-name"])).toHaveValue(menuName);
    console.log('‚úÖ Menu name filled');
  }

  
  async uploadMenuImage(imagePath, imageName) {
    console.log(`üì∏ Uploading ${imageName}...`);

    // Click on Choose image button
    await this.page.getByText('Choose image').click();

    // Set input files
    await this.page.setInputFiles('input[type="file"]', imagePath);
    console.log('‚úÖ Image file selected');

    // Wait for image to be visible
    await this.page.waitForTimeout(2000);
    await expect(this.page.getByRole('img', { name: 'Upload image*' })).toBeVisible();
    console.log('‚úÖ Image visible');

    // Click upload button
    await this.page.getByRole('button', { name: 'Upload' }).click();

    // Wait for upload to complete
    try {
      await this.page.waitForFunction(() => {
        const uploadModal = document.querySelector('[role="dialog"], .MuiDialog-root, .MuiModal-root');
        return !uploadModal || uploadModal.style.display === 'none';
      }, { timeout: 15000 });
      console.log(`‚úÖ ${imageName} uploaded successfully`);
    } catch (error) {
      console.log(`‚ö†Ô∏è Upload timeout for ${imageName}, continuing...`);
    }
  }


  /**
   * Save the menu
   */
  async saveMenu() {
    console.log('üíæ Saving menu...');
    await this.page.locator(locators["save-button"]).click();
    await this.page.waitForTimeout(3000);
    console.log('‚úÖ Menu save button clicked');
  }

  /**
   * Verify menu creation success
   */
  async verifyMenuCreation() {
    console.log('üîç Verifying menu creation...');

    // Check if we're on a menu-related page
    const currentUrl = this.page.url();
    const isOnMenuPage = currentUrl.includes('/menu') || currentUrl.includes('/menus');
  }
  async getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    // The expression is: Math.floor(Math.random() * (max - min + 1)) + min;
    // This calculates the size of the range (max - min + 1)
    // Multiplies Math.random() by it
    // Floors it to get an offset
    // And finally adds 'min' to shift the offset into the desired range
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

}
